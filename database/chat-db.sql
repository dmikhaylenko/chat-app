-- Пользователь
CREATE TABLE IF NOT EXISTS USER(
  ID                 BIGINT(20) NOT NULL AUTO_INCREMENT,
  PHONE              VARCHAR(50) NOT NULL,
  PASSWORD           VARCHAR(50) NOT NULL,
  USERNAME           VARCHAR(50) NOT NULL,
  AVATAR_HREF        VARCHAR(1000) NOT NULL,
  PRIMARY KEY(ID),
  UNIQUE(PHONE)
);

-- Контакт
CREATE TABLE IF NOT EXISTS CONTACT(
  WHOSE_ID           BIGINT(20) NOT NULL,
  WHO_ID             BIGINT(20) NOT NULL,
  PRIMARY KEY(WHOSE_ID, WHO_ID),
  FOREIGN KEY(WHOSE_ID) REFERENCES USER(ID),
  FOREIGN KEY(WHO_ID) REFERENCES USER(ID)
);

-- Аутентификация
CREATE TABLE IF NOT EXISTS AUTH(
  TOKEN             VARCHAR(64) NOT NULL,
  USER_ID           BIGINT(20) NOT NULL,
  EXP               TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00',
  LOGGED_IN         BOOLEAN NOT NULL DEFAULT TRUE,
  PRIMARY KEY(TOKEN),
  FOREIGN KEY(USER_ID) REFERENCES USER(ID)
);

-- Сообщение
CREATE TABLE IF NOT EXISTS MESSAGE(
  ID                BIGINT(20) NOT NULL AUTO_INCREMENT,
  SRC_ID            BIGINT(20) NOT NULL,
  DEST_ID           BIGINT(20) NOT NULL,
  WATCHED           BOOLEAN NOT NULL DEFAULT FALSE,
  MESSAGE           VARCHAR(500) NOT NULL,
  PRIMARY KEY(ID),
  FOREIGN KEY(SRC_ID) REFERENCES USER(ID),
  FOREIGN KEY(DEST_ID) REFERENCES USER(ID)
);

DELIMITER /
DROP FUNCTION IF EXISTS AUTH_EXP_NXT
/
CREATE FUNCTION AUTH_EXP_NXT() RETURNS TIMESTAMP
BEGIN
	DECLARE NXT_EXP TIMESTAMP DEFAULT CURRENT_TIMESTAMP();
    SELECT (CURRENT_TIMESTAMP + INTERVAL 1 MONTH) INTO NXT_EXP FROM DUAL;
    RETURN (NXT_EXP);
END
/
DELIMITER ;

DELIMITER /
DROP FUNCTION IF EXISTS IS_ACTIVE
/
CREATE FUNCTION IS_ACTIVE(_EXP TIMESTAMP, _LOGGED_IN BOOLEAN) RETURNS BOOLEAN
BEGIN
    RETURN (_LOGGED_IN AND CURRENT_TIMESTAMP() < _EXP);
END
/
DELIMITER ;

DELIMITER /
-- Проверка креденшелов
DROP FUNCTION IF EXISTS CHK_CREDS
/
CREATE FUNCTION CHK_CREDS(_USERNAME VARCHAR(50), _PASSWORD VARCHAR(50)) RETURNS BIGINT(20)
BEGIN
	DECLARE FOUND_USER BIGINT(20) DEFAULT NULL;
    SELECT U.ID INTO FOUND_USER FROM USER U WHERE U.PHONE = _USERNAME AND BINARY U.PASSWORD = _PASSWORD;
    RETURN (FOUND_USER);
END
/
DELIMITER ;

DELIMITER /
-- Вход пользователя в систему
DROP FUNCTION IF EXISTS LOGIN
/
CREATE FUNCTION LOGIN(_USERNAME VARCHAR(50), _PASSWORD VARCHAR(50)) RETURNS VARCHAR(64)
BEGIN
	DECLARE FOUND_USER BIGINT(20) DEFAULT NULL;
	DECLARE RESULT_TOKEN VARCHAR(64) DEFAULT NULL;
    SELECT CHK_CREDS(_USERNAME, _PASSWORD) INTO FOUND_USER FROM DUAL;
    IF FOUND_USER IS NOT NULL THEN
      SELECT A.TOKEN INTO RESULT_TOKEN FROM AUTH A WHERE A.USER_ID = FOUND_USER AND CURRENT_TIMESTAMP() < A.EXP AND A.LOGGED_IN = TRUE;
      IF RESULT_TOKEN IS NULL THEN
        SELECT SHA2(UUID(), 256) INTO RESULT_TOKEN FROM DUAL;
        INSERT INTO AUTH(TOKEN, USER_ID, EXP)
          SELECT RESULT_TOKEN AS TOKEN, FOUND_USER AS USER_ID, AUTH_EXP_NXT() AS EXP FROM DUAL;
      END IF;
    END IF;
    RETURN (RESULT_TOKEN);
END
/
DELIMITER ;

DELIMITER /
-- Выход пользователя из системы
DROP PROCEDURE IF EXISTS LOGOUT
/
CREATE PROCEDURE LOGOUT(IN _TOKEN VARCHAR(64))
BEGIN
	UPDATE AUTH SET LOGGED_IN = FALSE WHERE TOKEN = _TOKEN;
END
/
DELIMITER ;

DELIMITER /
-- Аутентификация по токену
DROP FUNCTION IF EXISTS AUTHENTICATE
/
CREATE FUNCTION AUTHENTICATE(_TOKEN VARCHAR(64)) RETURNS BOOLEAN
BEGIN
	DECLARE IS_AUTHENTICATED BOOLEAN DEFAULT FALSE;
    SELECT 
        (COUNT(*) > 0) INTO IS_AUTHENTICATED 
    FROM 
        AUTH 
    WHERE 
        TOKEN = _TOKEN AND 
        IS_ACTIVE(EXP, LOGGED_IN);
    RETURN (IS_AUTHENTICATED);
END
/
DELIMITER ;

-- Истории сообщений	
CREATE OR REPLACE VIEW VW_MESSAGE_HISTORY AS
    SELECT DISTINCT
        MY_AUTH.TOKEN,
        MY_AUTH.USER_ID,
        IF(MY_AUTH.USER_ID <> MSG.SRC_ID, MSG.SRC_ID, MSG.DEST_ID) AS OPPONENT_ID
    FROM 
        MESSAGE MSG 
        INNER JOIN AUTH MY_AUTH 
		    ON MY_AUTH.USER_ID IN (MSG.SRC_ID, MSG.DEST_ID)
    WHERE
        IS_ACTIVE(MY_AUTH.EXP, MY_AUTH.LOGGED_IN)
    UNION SELECT DISTINCT
        MY_AUTH.TOKEN,
        MY_AUTH.USER_ID,
        C.WHO_ID AS OPPONENT_ID
    FROM
        AUTH MY_AUTH
        INNER JOIN CONTACT C
            ON MY_AUTH.USER_ID = C.WHOSE_ID
    WHERE
        IS_ACTIVE(MY_AUTH.EXP, MY_AUTH.LOGGED_IN);

-- Cообщение
CREATE OR REPLACE VIEW VW_MESSAGE AS 
    SELECT DISTINCT
        U.ID AS USER_ID,
        IF(U.ID <> MSG.SRC_ID, MSG.SRC_ID, MSG.DEST_ID) AS OPPONENT_ID,
        MSG.ID AS MESSAGE_ID,
        MSG.SRC_ID AS MSG_AUTHOR,
        MSG.MESSAGE AS MESSAGE_BODY
    FROM
        MESSAGE MSG
        INNER JOIN USER U ON U.ID IN (MSG.SRC_ID, MSG.DEST_ID);
