-- Последовательности
CREATE TABLE IF NOT EXISTS SEQUENCES (
    SEQUENCE_NAME VARCHAR(40) NOT NULL,
    SEQUENCE_VALUE BIGINT(20) NOT NULL,
    LAST_HISTORY_MARKER VARCHAR(36) NOT NULL
);
ALTER TABLE SEQUENCES ADD CONSTRAINT PK__SEQUENCES PRIMARY KEY (SEQUENCE_NAME);
ALTER TABLE SEQUENCES ADD CONSTRAINT UNC__SEQUENCES__LAST_HISTORY_MARKER UNIQUE (LAST_HISTORY_MARKER);

-- История сгенерированных значений
CREATE TABLE IF NOT EXISTS SEQUENCE_VALUES_HISTORY (
    GUID VARCHAR(36) NOT NULL,
    SEQUENCE_NAME VARCHAR(40) NOT NULL,
    SEQUENCE_VALUE BIGINT(20) NOT NULL
);
ALTER TABLE SEQUENCE_VALUES_HISTORY ADD CONSTRAINT PK__SEQUENCE_VALUES_HISTORY PRIMARY KEY (GUID);
ALTER TABLE SEQUENCE_VALUES_HISTORY ADD CONSTRAINT FK__SEQUENCE_GENERATIONS$SEQUENCES FOREIGN KEY (SEQUENCE_NAME) REFERENCES SEQUENCES(SEQUENCE_NAME);

DELIMITER /
-- Триггер заполнения истории сгенерированных значений
DROP TRIGGER IF EXISTS TG__SEQUENCES__LOG_SEQUENCES_HISTORY
/
CREATE TRIGGER TG__SEQUENCES__LOG_SEQUENCES_HISTORY AFTER UPDATE ON SEQUENCES 
    FOR EACH ROW 
        INSERT INTO SEQUENCE_VALUES_HISTORY(SEQUENCE_NAME, GUID, SEQUENCE_VALUE) VALUES (NEW.SEQUENCE_NAME, NEW.LAST_HISTORY_MARKER, NEW.SEQUENCE_VALUE);
/
DELIMITER ;

DELIMITER /
-- Процедура создания последовательности
DROP PROCEDURE IF EXISTS CREATE_SEQ
/
CREATE PROCEDURE CREATE_SEQ(IN SEQ_NAME VARCHAR(40))
BEGIN
	INSERT INTO SEQUENCES(SEQUENCE_NAME, SEQUENCE_VALUE, LAST_HISTORY_MARKER) VALUES (SEQ_NAME, 0, UUID());
END
/
DELIMITER ;

DELIMITER /
-- Функция генерации следующего значения в последовательности
DROP FUNCTION IF EXISTS SEQ_NEXT
/
CREATE FUNCTION SEQ_NEXT(SEQ_NAME VARCHAR(40)) RETURNS BIGINT(20)
BEGIN
	DECLARE SQ_HISTORY_MARKER VARCHAR(36) DEFAULT UUID();
	DECLARE SQ_VALUE BIGINT(20) DEFAULT 0;
	UPDATE SEQUENCES SET SEQUENCE_VALUE=SEQUENCE_VALUE+1, LAST_HISTORY_MARKER = SQ_HISTORY_MARKER WHERE SEQUENCE_NAME=SEQ_NAME;
	SELECT HISTORY.SEQUENCE_VALUE INTO SQ_VALUE FROM SEQUENCE_VALUES_HISTORY HISTORY WHERE HISTORY.GUID = SQ_HISTORY_MARKER;
	RETURN (SQ_VALUE);
END
/
DELIMITER ;

DELIMITER /
-- Процедура сброса последовательности
DROP PROCEDURE IF EXISTS RESET_SEQ
/
CREATE PROCEDURE RESET_SEQ(IN SEQ_NAME VARCHAR(40))
BEGIN
	UPDATE SEQUENCES SET SEQUENCE_VALUE = 0, LAST_HISTORY_MARKER = UUID() WHERE SEQUENCE_NAME = SEQ_NAME;
END
/
DELIMITER ;

DELIMITER /
-- Процедура удаления последовательности
DROP PROCEDURE IF EXISTS DROP_SEQ
/
CREATE PROCEDURE DROP_SEQ(IN SEQ_NAME VARCHAR(40))
BEGIN
	DELETE FROM SEQUENCES WHERE SEQUENCE_NAME = SEQ_NAME;
END
/
DELIMITER ;

DELIMITER /
-- Очистка истории сгенерированных идентификаторов
DROP EVENT IF EXISTS CLEAR_SEQUENCE_GENERATIONS
/
CREATE EVENT CLEAR_SEQUENCE_GENERATIONS ON SCHEDULE EVERY 1 HOUR DO
BEGIN
	DELETE H.* 
    FROM SEQUENCE_VALUES_HISTORY H, 
         SEQUENCES S 
    WHERE H.SEQUENCE_NAME = S.SEQUENCE_NAME AND 
          H.SEQUENCE_VALUE < S.SEQUENCE_VALUE;
END
/
DELIMITER ;


-- Пользователь
CALL DROP_SEQ('SEQ__USER_ID');
CALL CREATE_SEQ('SEQ__USER_ID');
CREATE TABLE IF NOT EXISTS USER(
  ID                 BIGINT(20) NOT NULL AUTO_INCREMENT,
  PHONE              VARCHAR(50) NOT NULL,
  PASSWORD           VARCHAR(50) NOT NULL,
  USERNAME           VARCHAR(50) NOT NULL,
  AVATAR_HREF        VARCHAR(1000) NOT NULL,
  LAST_AUTH          TIMESTAMP NOT NULL DEFAULT NOW(),
  PRIMARY KEY(ID),
  UNIQUE(PHONE)
);

-- Контакт
CREATE TABLE IF NOT EXISTS CONTACT(
  WHOSE_ID           BIGINT(20) NOT NULL,
  WHO_ID             BIGINT(20) NOT NULL,
  PRIMARY KEY(WHOSE_ID, WHO_ID),
  FOREIGN KEY(WHOSE_ID) REFERENCES USER(ID),
  FOREIGN KEY(WHO_ID) REFERENCES USER(ID)
);

-- Аутентификация
CREATE TABLE IF NOT EXISTS AUTH(
  TOKEN             VARCHAR(64) NOT NULL,
  USER_ID           BIGINT(20) NOT NULL,
  EXP               TIMESTAMP NOT NULL DEFAULT '0000-00-00 00:00:00',
  LOGGED_IN         BOOLEAN NOT NULL DEFAULT TRUE,
  PRIMARY KEY(TOKEN),
  FOREIGN KEY(USER_ID) REFERENCES USER(ID)
);

-- Сообщение
CALL DROP_SEQ('SEQ__MESSAGE_ID');
CALL CREATE_SEQ('SEQ__MESSAGE_ID');
CREATE TABLE IF NOT EXISTS MESSAGE(
  ID                BIGINT(20) NOT NULL AUTO_INCREMENT,
  SRC_ID            BIGINT(20) NOT NULL,
  DEST_ID           BIGINT(20) NOT NULL,
  WATCHED           BOOLEAN NOT NULL DEFAULT FALSE,
  MESSAGE           VARCHAR(500) NOT NULL,
  POSTED            TIMESTAMP NOT NULL DEFAULT NOW(),
  PRIMARY KEY(ID),
  FOREIGN KEY(SRC_ID) REFERENCES USER(ID),
  FOREIGN KEY(DEST_ID) REFERENCES USER(ID)
);

DELIMITER /
DROP FUNCTION IF EXISTS AUTH_EXP_NXT
/
CREATE FUNCTION AUTH_EXP_NXT() RETURNS TIMESTAMP
BEGIN
	DECLARE NXT_EXP TIMESTAMP DEFAULT CURRENT_TIMESTAMP();
    SELECT (CURRENT_TIMESTAMP + INTERVAL 1 MONTH) INTO NXT_EXP FROM DUAL;
    RETURN (NXT_EXP);
END
/
DELIMITER ;

DELIMITER /
DROP FUNCTION IF EXISTS IS_ACTIVE
/
CREATE FUNCTION IS_ACTIVE(_EXP TIMESTAMP, _LOGGED_IN BOOLEAN) RETURNS BOOLEAN
BEGIN
    RETURN (_LOGGED_IN AND CURRENT_TIMESTAMP() < _EXP);
END
/
DELIMITER ;

DELIMITER /
-- Проверка креденшелов
DROP FUNCTION IF EXISTS CHK_CREDS
/
CREATE FUNCTION CHK_CREDS(_USERNAME VARCHAR(50), _PASSWORD VARCHAR(50)) RETURNS BIGINT(20)
BEGIN
	DECLARE FOUND_USER BIGINT(20) DEFAULT NULL;
    SELECT U.ID INTO FOUND_USER FROM USER U WHERE U.PHONE = _USERNAME AND BINARY U.PASSWORD = _PASSWORD;
    RETURN (FOUND_USER);
END
/
DELIMITER ;

DELIMITER /
-- Вход пользователя в систему
DROP FUNCTION IF EXISTS LOGIN
/
CREATE FUNCTION LOGIN(_USERNAME VARCHAR(50), _PASSWORD VARCHAR(50)) RETURNS VARCHAR(64)
BEGIN
	DECLARE FOUND_USER BIGINT(20) DEFAULT NULL;
	DECLARE RESULT_TOKEN VARCHAR(64) DEFAULT NULL;
    SELECT CHK_CREDS(_USERNAME, _PASSWORD) INTO FOUND_USER FROM DUAL;
    IF FOUND_USER IS NOT NULL THEN
      SELECT A.TOKEN INTO RESULT_TOKEN FROM AUTH A WHERE A.USER_ID = FOUND_USER AND CURRENT_TIMESTAMP() < A.EXP AND A.LOGGED_IN = TRUE;
      IF RESULT_TOKEN IS NULL THEN
        SELECT SHA2(UUID(), 256) INTO RESULT_TOKEN FROM DUAL;
        INSERT INTO AUTH(TOKEN, USER_ID, EXP)
          SELECT RESULT_TOKEN AS TOKEN, FOUND_USER AS USER_ID, AUTH_EXP_NXT() AS EXP FROM DUAL;
      END IF;
    END IF;
    RETURN (RESULT_TOKEN);
END
/
DELIMITER ;

DELIMITER /
-- Выход пользователя из системы
DROP PROCEDURE IF EXISTS LOGOUT
/
CREATE PROCEDURE LOGOUT(IN _TOKEN VARCHAR(64))
BEGIN
	UPDATE AUTH SET LOGGED_IN = FALSE WHERE TOKEN = _TOKEN;
END
/
DELIMITER ;

DELIMITER /
-- Аутентификация по токену
DROP FUNCTION IF EXISTS AUTHENTICATE
/
CREATE FUNCTION AUTHENTICATE(_TOKEN VARCHAR(64)) RETURNS BOOLEAN
BEGIN
	DECLARE IS_AUTHENTICATED BOOLEAN DEFAULT FALSE;
    SELECT 
        (COUNT(*) > 0) INTO IS_AUTHENTICATED 
    FROM 
        AUTH 
    WHERE 
        TOKEN = _TOKEN AND 
        IS_ACTIVE(EXP, LOGGED_IN);
	IF (IS_AUTHENTICATED) THEN
	    UPDATE 
		    USER 
		SET 
		    LAST_AUTH = NOW()
		WHERE
		    ID IN (
			    SELECT
				    USER_ID
			    FROM
				    AUTH
				WHERE
					TOKEN = _TOKEN
			);
	END IF;
    RETURN (IS_AUTHENTICATED);
END
/
DELIMITER ;

DELIMITER /
-- Проверка онлайн пользователь или нет
DROP FUNCTION IF EXISTS IS_ONLINE
/
CREATE FUNCTION IS_ONLINE(_LAST_AUTH TIMESTAMP) RETURNS BOOLEAN
BEGIN
    DECLARE IS_ONLINE BOOLEAN DEFAULT FALSE;
	SELECT 
	    COALESCE((_LAST_AUTH + INTERVAL 60 MINUTE) > NOW(), FALSE) INTO IS_ONLINE 
	FROM 
	    DUAL;
	RETURN (IS_ONLINE);
END
/
DELIMITER ;

-- Непрочитанные сообщения
CREATE OR REPLACE VIEW VW_UNWATCHED_MESSAGES AS
    SELECT
        U.ID AS USER_ID,
        M.SRC_ID AS OPPONENT_ID,
        COUNT(M.ID) AS UNWATCHED
    FROM
        USER U
        LEFT JOIN MESSAGE M
            ON U.ID = M.DEST_ID
    WHERE
        M.WATCHED = 0
    GROUP BY
        U.ID,
        M.SRC_ID;

-- Истории сообщений аутентифицированных пользователей
CREATE OR REPLACE VIEW VW_AUTHENTICATED_USER_HISTORIES AS
    SELECT DISTINCT
        A.TOKEN AS TOKEN,
        A.USER_ID AS USER_ID,
        IF (A.USER_ID <> MSG.SRC_ID, MSG.SRC_ID, MSG.DEST_ID) AS OPPONENT_ID
    FROM
        MESSAGE MSG
        INNER JOIN AUTH A
            ON A.USER_ID IN (MSG.SRC_ID, MSG.DEST_ID)
    UNION SELECT
        A.TOKEN AS TOKEN,
        A.USER_ID AS USER_ID,
        C.WHO_ID AS OPPONENT_ID
    FROM
        CONTACT C
        INNER JOIN AUTH A
            ON A.USER_ID = C.WHOSE_ID;
       
-- Истории сообщений	
CREATE OR REPLACE VIEW VW_MESSAGE_HISTORY AS
    SELECT
        H.TOKEN,
        H.USER_ID,
        H.OPPONENT_ID,
        U.USERNAME AS OPPONENT_NAME,
        U.AVATAR_HREF AS OPPONENT_HREF,
        U.LAST_AUTH AS OPPONENT_LAST_AUTH,
        COALESCE(UM.UNWATCHED, 0) AS UNWATCHED
    FROM
        VW_AUTHENTICATED_USER_HISTORIES H
        LEFT JOIN USER U
            ON H.OPPONENT_ID = U.ID
        LEFT JOIN VW_UNWATCHED_MESSAGES UM
            ON H.USER_ID = UM.USER_ID AND H.OPPONENT_ID = UM.OPPONENT_ID;

-- Cообщение
CREATE OR REPLACE VIEW VW_MESSAGE AS 
    SELECT DISTINCT
        U.ID AS USER_ID,
        IF(U.ID <> MSG.SRC_ID, MSG.SRC_ID, MSG.DEST_ID) AS OPPONENT_ID,
        MSG.ID AS MESSAGE_ID,
        MSG.SRC_ID AS MSG_AUTHOR,
        MSG.MESSAGE AS MESSAGE_BODY,
        MSG.POSTED AS MSG_POSTED,
        MSG.WATCHED  AS MSG_WATCHED
    FROM
        MESSAGE MSG
        INNER JOIN USER U ON U.ID IN (MSG.SRC_ID, MSG.DEST_ID);